template <typename T> /// Объявление шаблона. Ключевое слово typename говорит о том, что в шаблоне будет использоваться встроенный тип данных.
class Stack /// Объявление связанного класса Stack, который может работать с любым типом данных
{
private:
	struct Container 
	{ 
		T data; /// data: значение типа T, которое хранится в элементе стека.
		Container* next; /// Указатель на следующий элемент стека.
	};
public: /// Объявление публичных членов класса
	Container* top = nullptr; /// Указатель на верхний элемент стека, инициализируется nullptr
	int counter = 0; /// Счетчик элементов в стеке, инициализируется нулем.
	
	Stack() = default; /// Конструктор по умолчанию

	~Stack() /// Деструктор
	{
		clear(); /// Очищаем стек при уничтожении объекта
	}

	void push(T value) /// Добавляет новый элемент в стек. Он принимает значение типа T, которое будет добавлено.
	{ 
		Container* temp = new Container(); /// Создается новый элемент стека (объект Container) в динамической памяти.
		temp->data = value; /// Значение, переданное в метод, сохраняется в поле data нового элемента.
		temp->next = top; /// Указывает на текущий верхний элемент стека.
		top = temp; /// Указатель top обновляется, чтобы указывать на новый элемент, который теперь является верхним элементом стека.
		counter++; /// Увеличивается счетчик элементов в стеке.
	}

	T pop() /// Метод pop удаляет верхний элемент стека и возвращает его значение.
	{  
		if (top == nullptr) /// Проверка на пустоту стека.
		{  
			throw "Stack is empty!"; /// Если стек пуст, выбрасывается исключение с сообщением о том, что стек пуст.
		}
		Container* temp = top->next; /// Сохраняется указатель на следующий элемент стека (элемент под верхним).
		T value = top->data; /// Сохраняется значение верхнего элемента стека для возвращения.
		delete top; /// Удаляется верхний элемент стека из динамической памяти.
		top = temp; /// Указатель top обновляется, чтобы указывать на следующий элемент стека.
		counter--; /// Уменьшается счетчик элементов в стеке.
		return value; /// Возвращается значение, которое было у верхнего элемента стека.
	}

	T peek() /// Метод peek возвращает значение верхнего элемента стека, не удаляя его.
	{
		if (top == nullptr) /// Проверка на пустоту стека.
		{
			throw "Stack is empty!"; /// Если стек пуст, выбрасывается исключение.
		}
		T value = top->data; /// Сохраняется значение верхнего элемента стека.
		return value; /// Возвращается значение верхнего элемента стека.
	}

	int count() const /// Метод count возвращает количество элементов в стеке. 
					  /// Он объявлен как const, что означает, что он не изменяет состояние объекта.
	{
		return counter; /// Возвращается текущее значение счетчика элементов в стеке.
	}

	void clear() /// Метод clear очищает стек, удаляя все его элементы.
	{
		while (top != nullptr) /// Цикл продолжается, пока стек не станет пустым.
		{  
			Container* temp = top->next; /// Сохраняется указатель на следующий элемент стека.
			delete top; /// Удаляется верхний элемент стека.
			top = temp; /// Указатель top обновляется, чтобы указывать на следующий элемент.
		}
		counter = 0; /// Счётчик обнуляется, тк стек очистился.
	}
};
